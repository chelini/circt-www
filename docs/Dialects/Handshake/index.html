<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'builtin' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Handshake/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'builtin' Dialect</h1><p>A dialect containing the builtin Attributes, Operations, and Types</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#bfloat16-floating-point-type>bfloat16 floating-point type</a></li><li><a href=#complex-number-with-a-parameterized-element-type>Complex number with a parameterized element type</a></li><li><a href=#128-bit-floating-point-type>128-bit floating-point type</a></li><li><a href=#16-bit-floating-point-type>16-bit floating-point type</a></li><li><a href=#32-bit-floating-point-type>32-bit floating-point type</a></li><li><a href=#64-bit-floating-point-type>64-bit floating-point type</a></li><li><a href=#80-bit-floating-point-type>80-bit floating-point type</a></li><li><a href=#map-from-a-list-of-inputs-to-a-list-of-results>Map from a list of inputs to a list of results</a></li><li><a href=#integer-like-type-with-unknown-platform-dependent-bit-width>Integer-like type with unknown platform-dependent bit width</a></li><li><a href=#integer-type-with-arbitrary-precision-up-to-a-fixed-limit>Integer type with arbitrary precision up to a fixed limit</a></li><li><a href=#shaped-reference-to-a-region-of-memory>Shaped reference to a region of memory</a></li><li><a href=#a-unit-type>A unit type</a></li><li><a href=#type-of-a-non-registered-dialect>Type of a non-registered dialect</a></li><li><a href=#multi-dimensional-array-with-a-fixed-number-of-dimensions>Multi-dimensional array with a fixed number of dimensions</a></li><li><a href=#fixed-sized-collection-of-other-types>Fixed-sized collection of other types</a></li><li><a href=#shaped-reference-with-unknown-rank-to-a-region-of-memory>Shaped reference, with unknown rank, to a region of memory</a></li><li><a href=#multi-dimensional-array-with-unknown-dimensions>Multi-dimensional array with unknown dimensions</a></li><li><a href=#multi-dimensional-simd-vector-type>Multi-dimensional SIMD vector type</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#bfloat16type>BFloat16Type</a></li><li><a href=#complextype>ComplexType</a></li><li><a href=#float128type>Float128Type</a></li><li><a href=#float16type>Float16Type</a></li><li><a href=#float32type>Float32Type</a></li><li><a href=#float64type>Float64Type</a></li><li><a href=#float80type>Float80Type</a></li><li><a href=#functiontype>FunctionType</a></li><li><a href=#indextype>IndexType</a></li><li><a href=#integertype>IntegerType</a></li><li><a href=#memreftype>MemRefType</a></li><li><a href=#nonetype>NoneType</a></li><li><a href=#opaquetype>OpaqueType</a></li><li><a href=#rankedtensortype>RankedTensorType</a></li><li><a href=#tupletype>TupleType</a></li><li><a href=#unrankedmemreftype>UnrankedMemRefType</a></li><li><a href=#unrankedtensortype>UnrankedTensorType</a></li><li><a href=#vectortype>VectorType</a></li></ul></li></ul><ul><li><a href=#attribute-constraint-definition>Attribute constraint definition</a><ul><li><a href=#bufferop-seq-or-fifo>BufferOp seq or fifo</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#buffertypeenumattr>BufferTypeEnumAttr</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#handshakebr-circthandshakebranchop>handshake.br (::circt::handshake::BranchOp)</a></li><li><a href=#handshakebuffer-circthandshakebufferop>handshake.buffer (::circt::handshake::BufferOp)</a></li><li><a href=#handshakecond_br-circthandshakeconditionalbranchop>handshake.cond_br (::circt::handshake::ConditionalBranchOp)</a></li><li><a href=#handshakeconstant-circthandshakeconstantop>handshake.constant (::circt::handshake::ConstantOp)</a></li><li><a href=#handshakecontrol_merge-circthandshakecontrolmergeop>handshake.control_merge (::circt::handshake::ControlMergeOp)</a></li><li><a href=#handshakeend-circthandshakeendop>handshake.end (::circt::handshake::EndOp)</a></li><li><a href=#handshakeextmemory-circthandshakeexternalmemoryop>handshake.extmemory (::circt::handshake::ExternalMemoryOp)</a></li><li><a href=#handshakefork-circthandshakeforkop>handshake.fork (::circt::handshake::ForkOp)</a></li><li><a href=#handshakefunc-circthandshakefuncop>handshake.func (::circt::handshake::FuncOp)</a></li><li><a href=#handshakeinstance-circthandshakeinstanceop>handshake.instance (::circt::handshake::InstanceOp)</a></li><li><a href=#handshakejoin-circthandshakejoinop>handshake.join (::circt::handshake::JoinOp)</a></li><li><a href=#handshakelazy_fork-circthandshakelazyforkop>handshake.lazy_fork (::circt::handshake::LazyForkOp)</a></li><li><a href=#handshakeload-circthandshakeloadop>handshake.load (::circt::handshake::LoadOp)</a></li><li><a href=#handshakememory-circthandshakememoryop>handshake.memory (::circt::handshake::MemoryOp)</a></li><li><a href=#handshakemerge-circthandshakemergeop>handshake.merge (::circt::handshake::MergeOp)</a></li><li><a href=#handshakemux-circthandshakemuxop>handshake.mux (::circt::handshake::MuxOp)</a></li><li><a href=#handshakenever-circthandshakeneverop>handshake.never (::circt::handshake::NeverOp)</a></li><li><a href=#handshakepack-circthandshakepackop>handshake.pack (::circt::handshake::PackOp)</a></li><li><a href=#handshakereturn-circthandshakereturnop>handshake.return (::circt::handshake::ReturnOp)</a></li><li><a href=#handshakeselect-circthandshakeselectop>handshake.select (::circt::handshake::SelectOp)</a></li><li><a href=#handshakesink-circthandshakesinkop>handshake.sink (::circt::handshake::SinkOp)</a></li><li><a href=#handshakesource-circthandshakesourceop>handshake.source (::circt::handshake::SourceOp)</a></li><li><a href=#handshakestart-circthandshakestartop>handshake.start (::circt::handshake::StartOp)</a></li><li><a href=#handshakestore-circthandshakestoreop>handshake.store (::circt::handshake::StoreOp)</a></li><li><a href=#handshaketerminator-circthandshaketerminatorop>handshake.terminator (::circt::handshake::TerminatorOp)</a></li><li><a href=#handshakeunpack-circthandshakeunpackop>handshake.unpack (::circt::handshake::UnpackOp)</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=bfloat16-floating-point-type>bfloat16 floating-point type&nbsp;<a class=headline-hash href=#bfloat16-floating-point-type>¶</a></h3><h3 id=complex-number-with-a-parameterized-element-type>Complex number with a parameterized element type&nbsp;<a class=headline-hash href=#complex-number-with-a-parameterized-element-type>¶</a></h3><p>Syntax:</p><pre><code>complex-type ::= `complex` `&lt;` type `&gt;`
</code></pre><p>The value of <code>complex</code> type represents a complex number with a parameterized
element type, which is composed of a real and imaginary value of that
element type. The element must be a floating point or integer scalar type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>complex<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
complex<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h3 id=128-bit-floating-point-type>128-bit floating-point type&nbsp;<a class=headline-hash href=#128-bit-floating-point-type>¶</a></h3><h3 id=16-bit-floating-point-type>16-bit floating-point type&nbsp;<a class=headline-hash href=#16-bit-floating-point-type>¶</a></h3><h3 id=32-bit-floating-point-type>32-bit floating-point type&nbsp;<a class=headline-hash href=#32-bit-floating-point-type>¶</a></h3><h3 id=64-bit-floating-point-type>64-bit floating-point type&nbsp;<a class=headline-hash href=#64-bit-floating-point-type>¶</a></h3><h3 id=80-bit-floating-point-type>80-bit floating-point type&nbsp;<a class=headline-hash href=#80-bit-floating-point-type>¶</a></h3><h3 id=map-from-a-list-of-inputs-to-a-list-of-results>Map from a list of inputs to a list of results&nbsp;<a class=headline-hash href=#map-from-a-list-of-inputs-to-a-list-of-results>¶</a></h3><p>Syntax:</p><pre><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h3 id=integer-like-type-with-unknown-platform-dependent-bit-width>Integer-like type with unknown platform-dependent bit width&nbsp;<a class=headline-hash href=#integer-like-type-with-unknown-platform-dependent-bit-width>¶</a></h3><p>Syntax:</p><pre><code>// Target word-sized integer.
index-type ::= `index`
</code></pre><p>The index type is a signless integer whose size is equal to the natural
machine word of the target (
<a href=../../Rationale/Rationale/#integer-signedness-semantics>rationale</a> )
and is used by the affine constructs in MLIR.</p><p><strong>Rationale:</strong> integers of platform-specific bit widths are practical to
express sizes, dimensionalities and subscripts.</p><h3 id=integer-type-with-arbitrary-precision-up-to-a-fixed-limit>Integer type with arbitrary precision up to a fixed limit&nbsp;<a class=headline-hash href=#integer-type-with-arbitrary-precision-up-to-a-fixed-limit>¶</a></h3><p>Syntax:</p><pre><code>// Sized integers like i1, i4, i8, i16, i32.
signed-integer-type ::= `si` [1-9][0-9]*
unsigned-integer-type ::= `ui` [1-9][0-9]*
signless-integer-type ::= `i` [1-9][0-9]*
integer-type ::= signed-integer-type |
                 unsigned-integer-type |
                 signless-integer-type
</code></pre><p>Integer types have a designated bit width and may optionally have signedness
semantics.</p><p><strong>Rationale:</strong> low precision integers (like <code>i2</code>, <code>i4</code> etc) are useful for
low-precision inference chips, and arbitrary precision integers are useful
for hardware synthesis (where a 13 bit multiplier is a lot cheaper/smaller
than a 16 bit one).</p><h3 id=shaped-reference-to-a-region-of-memory>Shaped reference to a region of memory&nbsp;<a class=headline-hash href=#shaped-reference-to-a-region-of-memory>¶</a></h3><p>Syntax:</p><pre><code>memref-type ::= `memref` `&lt;` dimension-list-ranked type
                (`,` layout-specification)? (`,` memory-space)? `&gt;`

stride-list ::= `[` (dimension (`,` dimension)*)? `]`
strided-layout ::= `offset:` dimension `,` `strides: ` stride-list
layout-specification ::= semi-affine-map | strided-layout | attribute-value
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type is a reference to a region of memory (similar to a buffer
pointer, but more powerful). The buffer pointed to by a memref can be
allocated, aliased and deallocated. A memref can be used to read and write
data from/to the memory region which it references. Memref types use the
same shape specifier as tensor types. Note that <code>memref&lt;f32></code>,
<code>memref&lt;0 x f32></code>, <code>memref&lt;1 x 0 x f32></code>, and <code>memref&lt;0 x 1 x f32></code> are all
different types.</p><p>A <code>memref</code> is allowed to have an unknown rank (e.g. <code>memref&lt;*xf32></code>). The
purpose of unranked memrefs is to allow external library functions to
receive memref arguments of any rank without versioning the functions based
on the rank. Other uses of this type are disallowed or will have undefined
behavior.</p><p>Are accepted as elements:</p><ul><li>built-in integer types;</li><li>built-in index type;</li><li>built-in floating point types;</li><li>built-in vector types with elements of the above types;</li><li>another memref type;</li><li>any other type implementing <code>MemRefElementTypeInterface</code>.</li></ul><h5 id=codegen-of-unranked-memref>Codegen of Unranked Memref&nbsp;<a class=headline-hash href=#codegen-of-unranked-memref>¶</a></h5><p>Using unranked memref in codegen besides the case mentioned above is highly
discouraged. Codegen is concerned with generating loop nests and specialized
instructions for high-performance, unranked memref is concerned with hiding
the rank and thus, the number of enclosing loops required to iterate over
the data. However, if there is a need to code-gen unranked memref, one
possible path is to cast into a static ranked type based on the dynamic
rank. Another possible path is to emit a single while loop conditioned on a
linear index and perform delinearization of the linear index to a dynamic
array containing the (unranked) indices. While this is possible, it is
expected to not be a good idea to perform this during codegen as the cost
of the translations is expected to be prohibitive and optimizations at this
level are not expected to be worthwhile. If expressiveness is the main
concern, irrespective of performance, passing unranked memrefs to an
external C++ library and implementing rank-agnostic logic there is expected
to be significantly simpler.</p><p>Unranked memrefs may provide expressiveness gains in the future and help
bridge the gap with unranked tensors. Unranked memrefs will not be expected
to be exposed to codegen but one may query the rank of an unranked memref
(a special op will be needed for this purpose) and perform a switch and cast
to a ranked memref as a prerequisite to codegen.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// With static ranks, we need a function for each possible argument type
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
call <span class=nf>@helper_2D</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>
call <span class=nf>@helper_3D</span><span class=p>(</span><span class=nv>%B</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>

<span class=c>// With unknown rank, the functions can be unified under one unranked type
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Remove rank info
</span><span class=c></span><span class=nv>%A_u</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%A</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
<span class=nv>%B_u</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%B</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
<span class=c>// call same function with dynamic ranks
</span><span class=c></span>call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%A_u</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>
call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%B_u</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>
</code></pre></div><p>The core syntax and representation of a layout specification is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>. Additionally,
syntactic sugar is supported to make certain layout specifications more
intuitive to read. For the moment, a <code>memref</code> supports parsing a strided
form which is converted to a semi-affine map automatically.</p><p>The memory space of a memref is specified by a target-specific attribute.
It might be an integer value, string, dictionary or custom dialect attribute.
The empty memory space (attribute is None) is target specific.</p><p>The notionally dynamic value of a memref value includes the address of the
buffer allocated, as well as the symbols referred to by the shape, layout
map, and index maps.</p><p>Examples of memref static type</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Identity index/layout map
</span><span class=c></span><span class=nv>#identity</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Column major layout.
</span><span class=c></span><span class=nv>#col_major</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d2<span class=p>,</span> d1<span class=p>,</span> d0<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// A 2-d tiled layout with tiles of size 128 x 256.
</span><span class=c></span><span class=nv>#tiled_2d_128x256</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 div <span class=m>128</span><span class=p>,</span> d1 div <span class=m>256</span><span class=p>,</span> d0 mod <span class=m>128</span><span class=p>,</span> d1 mod <span class=m>256</span><span class=p>)</span><span class=p>&gt;</span>

<span class=c>// A tiled data layout with non-constant tile sizes.
</span><span class=c></span><span class=nv>#tiled_dynamic</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>,</span> s1<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 floordiv s0<span class=p>,</span> d1 floordiv s1<span class=p>,</span>
                             d0 mod s0<span class=p>,</span> d1 mod s1<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// A layout that yields a padding on two at either end of the minor dimension.
</span><span class=c></span><span class=nv>#padded</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> <span class=p>(</span>d1 <span class=err>+</span> <span class=m>2</span><span class=p>)</span> floordiv <span class=m>2</span><span class=p>,</span> <span class=p>(</span>d1 <span class=err>+</span> <span class=m>2</span><span class=p>)</span> mod <span class=m>2</span><span class=p>)</span><span class=p>&gt;</span>


<span class=c>// The dimension list &#34;16x32&#34; defines the following 2D index space:
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#identity</span><span class=p>&gt;</span>

<span class=c>// The dimension list &#34;16x4x?&#34; defines the following 3D index space:
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>//   { (i, j, k) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 4, 0 &lt;= k &lt; N }
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// where N is a symbol which represents the runtime value of the size of
</span><span class=c></span><span class=c>// the third dimension.
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// %N here binds to the size of the third dimension.
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%N</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#col_major</span><span class=p>&gt;</span>

<span class=c>// A 2-d dynamic shaped memref that also has a dynamically sized tiled
</span><span class=c></span><span class=c>// layout. The memref index space is of size %M x %N, while %B1 and %B2
</span><span class=c></span><span class=c>// bind to the symbols s0, s1 respectively of the layout map #tiled_dynamic.
</span><span class=c></span><span class=c>// Data tiles of size %B1 x %B2 in the logical space will be stored
</span><span class=c></span><span class=c>// contiguously in memory. The allocation size will be
</span><span class=c></span><span class=c>// (%M ceildiv %B1) * %B1 * (%N ceildiv %B2) * %B2 f32 elements.
</span><span class=c></span><span class=nv>%T</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%M</span><span class=p>,</span> <span class=nv>%N</span><span class=p>)</span> <span class=p>[</span><span class=nv>%B1</span><span class=p>,</span> <span class=nv>%B2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#tiled_dynamic</span><span class=p>&gt;</span>

<span class=c>// A memref that has a two-element padding at either end. The allocation
</span><span class=c></span><span class=c>// size will fit 16 * 64 float elements of data.
</span><span class=c></span><span class=nv>%P</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#padded</span><span class=p>&gt;</span>

<span class=c>// Affine map with symbol &#39;s0&#39; used as offset for the first dimension.
</span><span class=c></span><span class=nv>#imapS</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=err>+</span> s0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span>
<span class=c>// Allocate memref and bind the following symbols:
</span><span class=c></span><span class=c>// &#39;%n&#39; is bound to the dynamic second dimension of the memref type.
</span><span class=c></span><span class=c>// &#39;%o&#39; is bound to the symbol &#39;s0&#39; in the affine map of the memref type.
</span><span class=c></span><span class=nv>%n</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=nv>%o</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=nv>%A</span> <span class=p>=</span> alloc <span class=p>(</span><span class=nv>%n</span><span class=p>)</span><span class=p>[</span><span class=nv>%o</span><span class=p>]</span> <span class=p>:</span> <span class=p>&lt;</span><span class=m>16x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapS</span><span class=p>&gt;</span>
</code></pre></div><h5 id=index-space>Index Space&nbsp;<a class=headline-hash href=#index-space>¶</a></h5><p>A memref dimension list defines an index space within which the memref can
be indexed to access data.</p><h5 id=index>Index&nbsp;<a class=headline-hash href=#index>¶</a></h5><p>Data is accessed through a memref type using a multidimensional index into
the multidimensional index space defined by the memref&rsquo;s dimension list.</p><p>Examples</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Allocates a memref with 2D index space:
</span><span class=c></span><span class=c>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapA</span><span class=p>&gt;</span>

<span class=c>// Loads data from memref &#39;%A&#39; using a 2D index: (%i, %j)
</span><span class=c></span><span class=nv>%v</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapA</span><span class=p>&gt;</span>
</code></pre></div><h5 id=index-map>Index Map&nbsp;<a class=headline-hash href=#index-map>¶</a></h5><p>An index map is a one-to-one
<a href=Affine.md/#semi-affine-maps>semi-affine map</a> that transforms a
multidimensional index from one index space to another. For example, the
following figure shows an index map which maps a 2-dimensional index from a
2x2 index space to a 3x3 index space, using symbols <code>S0</code> and <code>S1</code> as
offsets.</p><p><img src=/includes/img/index-map.svg alt="Index Map Example"></p><p>The number of domain dimensions and range dimensions of an index map can be
different, but must match the number of dimensions of the input and output
index spaces on which the map operates. The index space is always
non-negative and integral. In addition, an index map must specify the size
of each of its range dimensions onto which it maps. Index map symbols must
be listed in order with symbols for dynamic dimension sizes first, followed
by other required symbols.</p><h5 id=layout-map>Layout Map&nbsp;<a class=headline-hash href=#layout-map>¶</a></h5><p>A layout map is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>
which encodes logical to physical index space mapping, by mapping input
dimensions to their ordering from most-major (slowest varying) to most-minor
(fastest varying). Therefore, an identity layout map corresponds to a
row-major layout. Identity layout maps do not contribute to the MemRef type
identification and are discarded on construction. That is, a type with an
explicit identity map is <code>memref&lt;?x?xf32, (i,j)->(i,j)></code> is strictly the
same as the one without layout maps, <code>memref&lt;?x?xf32></code>.</p><p>Layout map examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// MxN matrix stored in row major layout in memory:
</span><span class=c></span><span class=nv>#layout_map_row_major</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span>

<span class=c>// MxN matrix stored in column major layout in memory:
</span><span class=c></span><span class=nv>#layout_map_col_major</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>j<span class=p>,</span> i<span class=p>)</span>

<span class=c>// MxN matrix stored in a 2-d blocked/tiled layout with 64x64 tiles.
</span><span class=c></span><span class=nv>#layout_tiled</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>i floordiv <span class=m>64</span><span class=p>,</span> j floordiv <span class=m>64</span><span class=p>,</span> i mod <span class=m>64</span><span class=p>,</span> j mod <span class=m>64</span><span class=p>)</span>
</code></pre></div><h5 id=strided-memref>Strided MemRef&nbsp;<a class=headline-hash href=#strided-memref>¶</a></h5><p>A memref may specify a strided layout as part of its type. A stride
specification is a list of integer values that are either static or <code>?</code>
(dynamic case).
Strides encode the distance, in number of elements, in (linear) memory
between successive entries along a particular dimension. A stride
specification is syntactic sugar for an equivalent strided memref
representation with a <em>single</em> semi-affine map.</p><p>For example, <code>memref&lt;42x16xf32, offset: 33, strides: [1, 64]></code> specifies a
non-contiguous memory region of <code>42</code> by <code>16</code> <code>f32</code> elements such that:</p><ol><li>the minimal size of the enclosing memory region must be
<code>33 + 42 * 1 + 16 * 64 = 1066</code> elements;</li><li>the address calculation for accessing element <code>(i, j)</code> computes
<code>33 + i + 64 * j</code></li><li>the distance between two consecutive elements along the inner dimension
is <code>1</code> element and the distance between two consecutive elements along
the outer dimension is <code>64</code> elements.</li></ol><p>This corresponds to a column major view of the memory region and is
internally represented as the type
<code>memref&lt;42x16xf32, (i, j) -> (33 + i + 64 * j)></code>.</p><p>The specification of strides must not alias: given an n-D strided memref,
indices <code>(i1, ..., in)</code> and <code>(j1, ..., jn)</code> may not refer to the same memory
address unless <code>i1 == j1, ..., in == jn</code>.</p><p>Strided memrefs represent a view abstraction over preallocated data. They
are constructed with special ops, yet to be introduced. Strided memrefs are
a special subclass of memrefs with generic semi-affine map and correspond to
a normalized memref descriptor when lowering to LLVM.</p><h3 id=a-unit-type>A unit type&nbsp;<a class=headline-hash href=#a-unit-type>¶</a></h3><p>NoneType is a unit type, i.e. a type with exactly one possible value, where
its value does not have a defined dynamic representation.</p><h3 id=type-of-a-non-registered-dialect>Type of a non-registered dialect&nbsp;<a class=headline-hash href=#type-of-a-non-registered-dialect>¶</a></h3><p>Syntax:</p><pre><code>opaque-type ::= `opaque` `&lt;` type `&gt;`
</code></pre><p>Opaque types represent types of non-registered dialects. These are types
represented in their raw string form, and can only usefully be tested for
type equality.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>opaque<span class=p>&lt;</span><span class=s>&#34;llvm&#34;</span><span class=p>,</span> <span class=s>&#34;struct&lt;(i32, float)&gt;&#34;</span><span class=p>&gt;</span>
opaque<span class=p>&lt;</span><span class=s>&#34;pdl&#34;</span><span class=p>,</span> <span class=s>&#34;value&#34;</span><span class=p>&gt;</span>
</code></pre></div><h3 id=multi-dimensional-array-with-a-fixed-number-of-dimensions>Multi-dimensional array with a fixed number of dimensions&nbsp;<a class=headline-hash href=#multi-dimensional-array-with-a-fixed-number-of-dimensions>¶</a></h3><p>Syntax:</p><pre><code>tensor-type ::= `tensor` `&lt;` dimension-list type (`,` encoding)? `&gt;`
dimension-list ::= (dimension `x`)*
dimension ::= `?` | decimal-literal
encoding ::= attribute-value
</code></pre><p>Values with tensor type represents aggregate N-dimensional data values, and
have a known element type and a fixed rank with a list of dimensions. Each
dimension may be a static non-negative decimal constant or be dynamically
determined (indicated by <code>?</code>).</p><p>The runtime representation of the MLIR tensor type is intentionally
abstracted - you cannot control layout or get a pointer to the data. For
low level buffer access, MLIR has a
<a href=#memref-type><code>memref</code> type</a>. This
abstracted runtime representation holds both the tensor data values as well
as information about the (potentially dynamic) shape of the tensor. The
<a href=MemRef.md/#memrefdim-mlirmemrefdimop><code>dim</code> operation</a> returns the size of a
dimension from a value of tensor type.</p><p>The <code>encoding</code> attribute provides additional information on the tensor.
An empty attribute denotes a straightforward tensor without any specific
structure. But particular properties, like sparsity or other specific
characteristics of the data of the tensor can be encoded through this
attribute. The semantics are defined by a type and attribute interface
and must be respected by all passes that operate on tensor types.
TODO: provide this interface, and document it further.</p><p>Note: hexadecimal integer literals are not allowed in tensor type
declarations to avoid confusion between <code>0xf32</code> and <code>0 x f32</code>. Zero sizes
are allowed in tensors and treated as other sizes, e.g.,
<code>tensor&lt;0 x 1 x i32></code> and <code>tensor&lt;1 x 0 x i32></code> are different types. Since
zero sizes are not allowed in some other types, such tensors should be
optimized away before lowering tensors to vectors.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Known rank but unknown dimensions.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>? x</span> <span class=m>? x</span> <span class=m>? x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Partially known dimensions.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>? x</span> <span class=m>? x</span> <span class=m>13 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Full static shape.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>17 x</span> <span class=m>4 x</span> <span class=m>13 x</span> <span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor with rank zero. Represents a scalar.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Zero-element dimensions are allowed.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>0</span> <span class=p>x</span> <span class=m>42 x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Zero-element tensor of f32 type (hexadecimal literals not allowed here).
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>0xf32</span><span class=p>&gt;</span>

<span class=c>// Tensor with an encoding attribute (where #ENCODING is a named alias).
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f64</span><span class=p>,</span> <span class=nv>#ENCODING</span><span class=p>&gt;</span>
</code></pre></div><h3 id=fixed-sized-collection-of-other-types>Fixed-sized collection of other types&nbsp;<a class=headline-hash href=#fixed-sized-collection-of-other-types>¶</a></h3><p>Syntax:</p><pre><code>tuple-type ::= `tuple` `&lt;` (type ( `,` type)*)? `&gt;`
</code></pre><p>The value of <code>tuple</code> type represents a fixed-size collection of elements,
where each element may be of a different type.</p><p><strong>Rationale:</strong> Though this type is first class in the type system, MLIR
provides no standard operations for operating on <code>tuple</code> types
(
<a href=../../Rationale/Rationale/#tuple-types>rationale</a>).</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Empty tuple.
</span><span class=c></span>tuple<span class=p>&lt;</span><span class=p>&gt;</span>

<span class=c>// Single element
</span><span class=c></span>tuple<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Many elements.
</span><span class=c></span>tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i5</span><span class=p>&gt;</span>
</code></pre></div><h3 id=shaped-reference-with-unknown-rank-to-a-region-of-memory>Shaped reference, with unknown rank, to a region of memory&nbsp;<a class=headline-hash href=#shaped-reference-with-unknown-rank-to-a-region-of-memory>¶</a></h3><p>Syntax:</p><pre><code>unranked-memref-type ::= `memref` `&lt;*x` type (`,` memory-space)? `&gt;`
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type with an unknown rank (e.g. <code>memref&lt;*xf32></code>). The purpose of
unranked memrefs is to allow external library functions to receive memref
arguments of any rank without versioning the functions based on the rank.
Other uses of this type are disallowed or will have undefined behavior.</p><p>See
<a href=#builtin_memref-memreftype>MemRefType</a> for more information on
memref types.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// An unranked memref with a memory space of 10.
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span><span class=k>f32</span><span class=p>,</span> <span class=m>10</span><span class=p>&gt;</span>
</code></pre></div><h3 id=multi-dimensional-array-with-unknown-dimensions>Multi-dimensional array with unknown dimensions&nbsp;<a class=headline-hash href=#multi-dimensional-array-with-unknown-dimensions>¶</a></h3><p>Syntax:</p><pre><code>tensor-type ::= `tensor` `&lt;` `*` `x` type `&gt;`
</code></pre><p>An unranked tensor is a type of tensor in which the set of dimensions have
unknown rank. See
<a href=#builtin_rankedtensor-rankedtensortype>RankedTensorType</a>
for more information on tensor types.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h3 id=multi-dimensional-simd-vector-type>Multi-dimensional SIMD vector type&nbsp;<a class=headline-hash href=#multi-dimensional-simd-vector-type>¶</a></h3><p>Syntax:</p><pre><code>vector-type ::= `vector` `&lt;` vector-dim-list vector-element-type `&gt;`
vector-element-type ::= float-type | integer-type | index-type
vector-dim-list := (static-dim-list `x`)? (`[` static-dim-list `]` `x`)?
static-dim-list ::= decimal-literal (`x` decimal-literal)*
</code></pre><p>The vector type represents a SIMD style vector used by target-specific
operation sets like AVX or SVE. While the most common use is for 1D
vectors (e.g. vector&lt;16 x f32>) we also support multidimensional registers
on targets that support them (like TPUs). The dimensions of a vector type
can be fixed-length, scalable, or a combination of the two. The scalable
dimensions in a vector are indicated between square brackets ([ ]), and
all fixed-length dimensions, if present, must precede the set of scalable
dimensions. That is, a <code>vector&lt;2x[4]xf32></code> is valid, but <code>vector&lt;[4]x2xf32></code>
is not.</p><p>Vector shapes must be positive decimal integers. 0D vectors are allowed by
omitting the dimension: <code>vector&lt;f32></code>.</p><p>Note: hexadecimal integer literals are not allowed in vector type
declarations, <code>vector&lt;0x42xi32></code> is invalid because it is interpreted as a
2D vector with shape <code>(0, 42)</code> and zero shapes are not allowed.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A 2D fixed-length vector of 3x42 i32 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x42x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// A 1D scalable-length vector that contains a multiple of 4 f32 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=p>[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>

<span class=c>// A 2D scalable-length vector that contains a multiple of 2x8 i8 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=p>[</span><span class=m>2x</span><span class=m>8</span><span class=p>]</span>xf32<span class=p>&gt;</span>

<span class=c>// A 2D mixed fixed/scalable vector that contains 4 scalable vectors of 4 f32 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=p>[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</code></pre></div><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=bfloat16type>BFloat16Type&nbsp;<a class=headline-hash href=#bfloat16type>¶</a></h3><p>bfloat16 floating-point type</p><h3 id=complextype>ComplexType&nbsp;<a class=headline-hash href=#complextype>¶</a></h3><p>Complex number with a parameterized element type</p><p>Syntax:</p><pre><code>complex-type ::= `complex` `&lt;` type `&gt;`
</code></pre><p>The value of <code>complex</code> type represents a complex number with a parameterized
element type, which is composed of a real and imaginary value of that
element type. The element must be a floating point or integer scalar type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>complex<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
complex<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>Type</code></td><td></td></tr></tbody></table><h3 id=float128type>Float128Type&nbsp;<a class=headline-hash href=#float128type>¶</a></h3><p>128-bit floating-point type</p><h3 id=float16type>Float16Type&nbsp;<a class=headline-hash href=#float16type>¶</a></h3><p>16-bit floating-point type</p><h3 id=float32type>Float32Type&nbsp;<a class=headline-hash href=#float32type>¶</a></h3><p>32-bit floating-point type</p><h3 id=float64type>Float64Type&nbsp;<a class=headline-hash href=#float64type>¶</a></h3><p>64-bit floating-point type</p><h3 id=float80type>Float80Type&nbsp;<a class=headline-hash href=#float80type>¶</a></h3><p>80-bit floating-point type</p><h3 id=functiontype>FunctionType&nbsp;<a class=headline-hash href=#functiontype>¶</a></h3><p>Map from a list of inputs to a list of results</p><p>Syntax:</p><pre><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>inputs</td><td align=center><code>ArrayRef&lt;Type></code></td><td></td></tr><tr><td align=center>results</td><td align=center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=indextype>IndexType&nbsp;<a class=headline-hash href=#indextype>¶</a></h3><p>Integer-like type with unknown platform-dependent bit width</p><p>Syntax:</p><pre><code>// Target word-sized integer.
index-type ::= `index`
</code></pre><p>The index type is a signless integer whose size is equal to the natural
machine word of the target (
<a href=../../Rationale/Rationale/#integer-signedness-semantics>rationale</a> )
and is used by the affine constructs in MLIR.</p><p><strong>Rationale:</strong> integers of platform-specific bit widths are practical to
express sizes, dimensionalities and subscripts.</p><h3 id=integertype>IntegerType&nbsp;<a class=headline-hash href=#integertype>¶</a></h3><p>Integer type with arbitrary precision up to a fixed limit</p><p>Syntax:</p><pre><code>// Sized integers like i1, i4, i8, i16, i32.
signed-integer-type ::= `si` [1-9][0-9]*
unsigned-integer-type ::= `ui` [1-9][0-9]*
signless-integer-type ::= `i` [1-9][0-9]*
integer-type ::= signed-integer-type |
                 unsigned-integer-type |
                 signless-integer-type
</code></pre><p>Integer types have a designated bit width and may optionally have signedness
semantics.</p><p><strong>Rationale:</strong> low precision integers (like <code>i2</code>, <code>i4</code> etc) are useful for
low-precision inference chips, and arbitrary precision integers are useful
for hardware synthesis (where a 13 bit multiplier is a lot cheaper/smaller
than a 16 bit one).</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>width</td><td align=center><code>unsigned</code></td><td></td></tr><tr><td align=center>signedness</td><td align=center><code>SignednessSemantics</code></td><td></td></tr></tbody></table><h3 id=memreftype>MemRefType&nbsp;<a class=headline-hash href=#memreftype>¶</a></h3><p>Shaped reference to a region of memory</p><p>Syntax:</p><pre><code>memref-type ::= `memref` `&lt;` dimension-list-ranked type
                (`,` layout-specification)? (`,` memory-space)? `&gt;`

stride-list ::= `[` (dimension (`,` dimension)*)? `]`
strided-layout ::= `offset:` dimension `,` `strides: ` stride-list
layout-specification ::= semi-affine-map | strided-layout | attribute-value
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type is a reference to a region of memory (similar to a buffer
pointer, but more powerful). The buffer pointed to by a memref can be
allocated, aliased and deallocated. A memref can be used to read and write
data from/to the memory region which it references. Memref types use the
same shape specifier as tensor types. Note that <code>memref&lt;f32></code>,
<code>memref&lt;0 x f32></code>, <code>memref&lt;1 x 0 x f32></code>, and <code>memref&lt;0 x 1 x f32></code> are all
different types.</p><p>A <code>memref</code> is allowed to have an unknown rank (e.g. <code>memref&lt;*xf32></code>). The
purpose of unranked memrefs is to allow external library functions to
receive memref arguments of any rank without versioning the functions based
on the rank. Other uses of this type are disallowed or will have undefined
behavior.</p><p>Are accepted as elements:</p><ul><li>built-in integer types;</li><li>built-in index type;</li><li>built-in floating point types;</li><li>built-in vector types with elements of the above types;</li><li>another memref type;</li><li>any other type implementing <code>MemRefElementTypeInterface</code>.</li></ul><h5 id=codegen-of-unranked-memref-1>Codegen of Unranked Memref&nbsp;<a class=headline-hash href=#codegen-of-unranked-memref-1>¶</a></h5><p>Using unranked memref in codegen besides the case mentioned above is highly
discouraged. Codegen is concerned with generating loop nests and specialized
instructions for high-performance, unranked memref is concerned with hiding
the rank and thus, the number of enclosing loops required to iterate over
the data. However, if there is a need to code-gen unranked memref, one
possible path is to cast into a static ranked type based on the dynamic
rank. Another possible path is to emit a single while loop conditioned on a
linear index and perform delinearization of the linear index to a dynamic
array containing the (unranked) indices. While this is possible, it is
expected to not be a good idea to perform this during codegen as the cost
of the translations is expected to be prohibitive and optimizations at this
level are not expected to be worthwhile. If expressiveness is the main
concern, irrespective of performance, passing unranked memrefs to an
external C++ library and implementing rank-agnostic logic there is expected
to be significantly simpler.</p><p>Unranked memrefs may provide expressiveness gains in the future and help
bridge the gap with unranked tensors. Unranked memrefs will not be expected
to be exposed to codegen but one may query the rank of an unranked memref
(a special op will be needed for this purpose) and perform a switch and cast
to a ranked memref as a prerequisite to codegen.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// With static ranks, we need a function for each possible argument type
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
call <span class=nf>@helper_2D</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>
call <span class=nf>@helper_3D</span><span class=p>(</span><span class=nv>%B</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>

<span class=c>// With unknown rank, the functions can be unified under one unranked type
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Remove rank info
</span><span class=c></span><span class=nv>%A_u</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%A</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
<span class=nv>%B_u</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%B</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
<span class=c>// call same function with dynamic ranks
</span><span class=c></span>call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%A_u</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>
call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%B_u</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span><span class=p>-&gt;</span><span class=p>(</span><span class=p>)</span>
</code></pre></div><p>The core syntax and representation of a layout specification is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>. Additionally,
syntactic sugar is supported to make certain layout specifications more
intuitive to read. For the moment, a <code>memref</code> supports parsing a strided
form which is converted to a semi-affine map automatically.</p><p>The memory space of a memref is specified by a target-specific attribute.
It might be an integer value, string, dictionary or custom dialect attribute.
The empty memory space (attribute is None) is target specific.</p><p>The notionally dynamic value of a memref value includes the address of the
buffer allocated, as well as the symbols referred to by the shape, layout
map, and index maps.</p><p>Examples of memref static type</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Identity index/layout map
</span><span class=c></span><span class=nv>#identity</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Column major layout.
</span><span class=c></span><span class=nv>#col_major</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d2<span class=p>,</span> d1<span class=p>,</span> d0<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// A 2-d tiled layout with tiles of size 128 x 256.
</span><span class=c></span><span class=nv>#tiled_2d_128x256</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 div <span class=m>128</span><span class=p>,</span> d1 div <span class=m>256</span><span class=p>,</span> d0 mod <span class=m>128</span><span class=p>,</span> d1 mod <span class=m>256</span><span class=p>)</span><span class=p>&gt;</span>

<span class=c>// A tiled data layout with non-constant tile sizes.
</span><span class=c></span><span class=nv>#tiled_dynamic</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>,</span> s1<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 floordiv s0<span class=p>,</span> d1 floordiv s1<span class=p>,</span>
                             d0 mod s0<span class=p>,</span> d1 mod s1<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// A layout that yields a padding on two at either end of the minor dimension.
</span><span class=c></span><span class=nv>#padded</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> <span class=p>(</span>d1 <span class=err>+</span> <span class=m>2</span><span class=p>)</span> floordiv <span class=m>2</span><span class=p>,</span> <span class=p>(</span>d1 <span class=err>+</span> <span class=m>2</span><span class=p>)</span> mod <span class=m>2</span><span class=p>)</span><span class=p>&gt;</span>


<span class=c>// The dimension list &#34;16x32&#34; defines the following 2D index space:
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#identity</span><span class=p>&gt;</span>

<span class=c>// The dimension list &#34;16x4x?&#34; defines the following 3D index space:
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>//   { (i, j, k) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 4, 0 &lt;= k &lt; N }
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// where N is a symbol which represents the runtime value of the size of
</span><span class=c></span><span class=c>// the third dimension.
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// %N here binds to the size of the third dimension.
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%N</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#col_major</span><span class=p>&gt;</span>

<span class=c>// A 2-d dynamic shaped memref that also has a dynamically sized tiled
</span><span class=c></span><span class=c>// layout. The memref index space is of size %M x %N, while %B1 and %B2
</span><span class=c></span><span class=c>// bind to the symbols s0, s1 respectively of the layout map #tiled_dynamic.
</span><span class=c></span><span class=c>// Data tiles of size %B1 x %B2 in the logical space will be stored
</span><span class=c></span><span class=c>// contiguously in memory. The allocation size will be
</span><span class=c></span><span class=c>// (%M ceildiv %B1) * %B1 * (%N ceildiv %B2) * %B2 f32 elements.
</span><span class=c></span><span class=nv>%T</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%M</span><span class=p>,</span> <span class=nv>%N</span><span class=p>)</span> <span class=p>[</span><span class=nv>%B1</span><span class=p>,</span> <span class=nv>%B2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#tiled_dynamic</span><span class=p>&gt;</span>

<span class=c>// A memref that has a two-element padding at either end. The allocation
</span><span class=c></span><span class=c>// size will fit 16 * 64 float elements of data.
</span><span class=c></span><span class=nv>%P</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#padded</span><span class=p>&gt;</span>

<span class=c>// Affine map with symbol &#39;s0&#39; used as offset for the first dimension.
</span><span class=c></span><span class=nv>#imapS</span> <span class=p>=</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=err>+</span> s0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span>
<span class=c>// Allocate memref and bind the following symbols:
</span><span class=c></span><span class=c>// &#39;%n&#39; is bound to the dynamic second dimension of the memref type.
</span><span class=c></span><span class=c>// &#39;%o&#39; is bound to the symbol &#39;s0&#39; in the affine map of the memref type.
</span><span class=c></span><span class=nv>%n</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=nv>%o</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=nv>%A</span> <span class=p>=</span> alloc <span class=p>(</span><span class=nv>%n</span><span class=p>)</span><span class=p>[</span><span class=nv>%o</span><span class=p>]</span> <span class=p>:</span> <span class=p>&lt;</span><span class=m>16x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapS</span><span class=p>&gt;</span>
</code></pre></div><h5 id=index-space-1>Index Space&nbsp;<a class=headline-hash href=#index-space-1>¶</a></h5><p>A memref dimension list defines an index space within which the memref can
be indexed to access data.</p><h5 id=index-1>Index&nbsp;<a class=headline-hash href=#index-1>¶</a></h5><p>Data is accessed through a memref type using a multidimensional index into
the multidimensional index space defined by the memref&rsquo;s dimension list.</p><p>Examples</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Allocates a memref with 2D index space:
</span><span class=c></span><span class=c>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapA</span><span class=p>&gt;</span>

<span class=c>// Loads data from memref &#39;%A&#39; using a 2D index: (%i, %j)
</span><span class=c></span><span class=nv>%v</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapA</span><span class=p>&gt;</span>
</code></pre></div><h5 id=index-map-1>Index Map&nbsp;<a class=headline-hash href=#index-map-1>¶</a></h5><p>An index map is a one-to-one
<a href=Affine.md/#semi-affine-maps>semi-affine map</a> that transforms a
multidimensional index from one index space to another. For example, the
following figure shows an index map which maps a 2-dimensional index from a
2x2 index space to a 3x3 index space, using symbols <code>S0</code> and <code>S1</code> as
offsets.</p><p><img src=/includes/img/index-map.svg alt="Index Map Example"></p><p>The number of domain dimensions and range dimensions of an index map can be
different, but must match the number of dimensions of the input and output
index spaces on which the map operates. The index space is always
non-negative and integral. In addition, an index map must specify the size
of each of its range dimensions onto which it maps. Index map symbols must
be listed in order with symbols for dynamic dimension sizes first, followed
by other required symbols.</p><h5 id=layout-map-1>Layout Map&nbsp;<a class=headline-hash href=#layout-map-1>¶</a></h5><p>A layout map is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>
which encodes logical to physical index space mapping, by mapping input
dimensions to their ordering from most-major (slowest varying) to most-minor
(fastest varying). Therefore, an identity layout map corresponds to a
row-major layout. Identity layout maps do not contribute to the MemRef type
identification and are discarded on construction. That is, a type with an
explicit identity map is <code>memref&lt;?x?xf32, (i,j)->(i,j)></code> is strictly the
same as the one without layout maps, <code>memref&lt;?x?xf32></code>.</p><p>Layout map examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// MxN matrix stored in row major layout in memory:
</span><span class=c></span><span class=nv>#layout_map_row_major</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span>

<span class=c>// MxN matrix stored in column major layout in memory:
</span><span class=c></span><span class=nv>#layout_map_col_major</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>j<span class=p>,</span> i<span class=p>)</span>

<span class=c>// MxN matrix stored in a 2-d blocked/tiled layout with 64x64 tiles.
</span><span class=c></span><span class=nv>#layout_tiled</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>i floordiv <span class=m>64</span><span class=p>,</span> j floordiv <span class=m>64</span><span class=p>,</span> i mod <span class=m>64</span><span class=p>,</span> j mod <span class=m>64</span><span class=p>)</span>
</code></pre></div><h5 id=strided-memref-1>Strided MemRef&nbsp;<a class=headline-hash href=#strided-memref-1>¶</a></h5><p>A memref may specify a strided layout as part of its type. A stride
specification is a list of integer values that are either static or <code>?</code>
(dynamic case).
Strides encode the distance, in number of elements, in (linear) memory
between successive entries along a particular dimension. A stride
specification is syntactic sugar for an equivalent strided memref
representation with a <em>single</em> semi-affine map.</p><p>For example, <code>memref&lt;42x16xf32, offset: 33, strides: [1, 64]></code> specifies a
non-contiguous memory region of <code>42</code> by <code>16</code> <code>f32</code> elements such that:</p><ol><li>the minimal size of the enclosing memory region must be
<code>33 + 42 * 1 + 16 * 64 = 1066</code> elements;</li><li>the address calculation for accessing element <code>(i, j)</code> computes
<code>33 + i + 64 * j</code></li><li>the distance between two consecutive elements along the inner dimension
is <code>1</code> element and the distance between two consecutive elements along
the outer dimension is <code>64</code> elements.</li></ol><p>This corresponds to a column major view of the memory region and is
internally represented as the type
<code>memref&lt;42x16xf32, (i, j) -> (33 + i + 64 * j)></code>.</p><p>The specification of strides must not alias: given an n-D strided memref,
indices <code>(i1, ..., in)</code> and <code>(j1, ..., jn)</code> may not refer to the same memory
address unless <code>i1 == j1, ..., in == jn</code>.</p><p>Strided memrefs represent a view abstraction over preallocated data. They
are constructed with special ops, yet to be introduced. Strided memrefs are
a special subclass of memrefs with generic semi-affine map and correspond to
a normalized memref descriptor when lowering to LLVM.</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>shape</td><td align=center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td align=center>elementType</td><td align=center><code>Type</code></td><td></td></tr><tr><td align=center>layout</td><td align=center><code>MemRefLayoutAttrInterface</code></td><td></td></tr><tr><td align=center>memorySpace</td><td align=center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=nonetype>NoneType&nbsp;<a class=headline-hash href=#nonetype>¶</a></h3><p>A unit type</p><p>NoneType is a unit type, i.e. a type with exactly one possible value, where
its value does not have a defined dynamic representation.</p><h3 id=opaquetype>OpaqueType&nbsp;<a class=headline-hash href=#opaquetype>¶</a></h3><p>Type of a non-registered dialect</p><p>Syntax:</p><pre><code>opaque-type ::= `opaque` `&lt;` type `&gt;`
</code></pre><p>Opaque types represent types of non-registered dialects. These are types
represented in their raw string form, and can only usefully be tested for
type equality.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>opaque<span class=p>&lt;</span><span class=s>&#34;llvm&#34;</span><span class=p>,</span> <span class=s>&#34;struct&lt;(i32, float)&gt;&#34;</span><span class=p>&gt;</span>
opaque<span class=p>&lt;</span><span class=s>&#34;pdl&#34;</span><span class=p>,</span> <span class=s>&#34;value&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>dialectNamespace</td><td align=center><code>StringAttr</code></td><td></td></tr><tr><td align=center>typeData</td><td align=center><code>::llvm::StringRef</code></td><td></td></tr></tbody></table><h3 id=rankedtensortype>RankedTensorType&nbsp;<a class=headline-hash href=#rankedtensortype>¶</a></h3><p>Multi-dimensional array with a fixed number of dimensions</p><p>Syntax:</p><pre><code>tensor-type ::= `tensor` `&lt;` dimension-list type (`,` encoding)? `&gt;`
dimension-list ::= (dimension `x`)*
dimension ::= `?` | decimal-literal
encoding ::= attribute-value
</code></pre><p>Values with tensor type represents aggregate N-dimensional data values, and
have a known element type and a fixed rank with a list of dimensions. Each
dimension may be a static non-negative decimal constant or be dynamically
determined (indicated by <code>?</code>).</p><p>The runtime representation of the MLIR tensor type is intentionally
abstracted - you cannot control layout or get a pointer to the data. For
low level buffer access, MLIR has a
<a href=#memref-type><code>memref</code> type</a>. This
abstracted runtime representation holds both the tensor data values as well
as information about the (potentially dynamic) shape of the tensor. The
<a href=MemRef.md/#memrefdim-mlirmemrefdimop><code>dim</code> operation</a> returns the size of a
dimension from a value of tensor type.</p><p>The <code>encoding</code> attribute provides additional information on the tensor.
An empty attribute denotes a straightforward tensor without any specific
structure. But particular properties, like sparsity or other specific
characteristics of the data of the tensor can be encoded through this
attribute. The semantics are defined by a type and attribute interface
and must be respected by all passes that operate on tensor types.
TODO: provide this interface, and document it further.</p><p>Note: hexadecimal integer literals are not allowed in tensor type
declarations to avoid confusion between <code>0xf32</code> and <code>0 x f32</code>. Zero sizes
are allowed in tensors and treated as other sizes, e.g.,
<code>tensor&lt;0 x 1 x i32></code> and <code>tensor&lt;1 x 0 x i32></code> are different types. Since
zero sizes are not allowed in some other types, such tensors should be
optimized away before lowering tensors to vectors.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Known rank but unknown dimensions.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>? x</span> <span class=m>? x</span> <span class=m>? x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Partially known dimensions.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>? x</span> <span class=m>? x</span> <span class=m>13 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Full static shape.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>17 x</span> <span class=m>4 x</span> <span class=m>13 x</span> <span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor with rank zero. Represents a scalar.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Zero-element dimensions are allowed.
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>0</span> <span class=p>x</span> <span class=m>42 x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Zero-element tensor of f32 type (hexadecimal literals not allowed here).
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>0xf32</span><span class=p>&gt;</span>

<span class=c>// Tensor with an encoding attribute (where #ENCODING is a named alias).
</span><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f64</span><span class=p>,</span> <span class=nv>#ENCODING</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>shape</td><td align=center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td align=center>elementType</td><td align=center><code>Type</code></td><td></td></tr><tr><td align=center>encoding</td><td align=center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=tupletype>TupleType&nbsp;<a class=headline-hash href=#tupletype>¶</a></h3><p>Fixed-sized collection of other types</p><p>Syntax:</p><pre><code>tuple-type ::= `tuple` `&lt;` (type ( `,` type)*)? `&gt;`
</code></pre><p>The value of <code>tuple</code> type represents a fixed-size collection of elements,
where each element may be of a different type.</p><p><strong>Rationale:</strong> Though this type is first class in the type system, MLIR
provides no standard operations for operating on <code>tuple</code> types
(
<a href=../../Rationale/Rationale/#tuple-types>rationale</a>).</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Empty tuple.
</span><span class=c></span>tuple<span class=p>&lt;</span><span class=p>&gt;</span>

<span class=c>// Single element
</span><span class=c></span>tuple<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Many elements.
</span><span class=c></span>tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i5</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>types</td><td align=center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=unrankedmemreftype>UnrankedMemRefType&nbsp;<a class=headline-hash href=#unrankedmemreftype>¶</a></h3><p>Shaped reference, with unknown rank, to a region of memory</p><p>Syntax:</p><pre><code>unranked-memref-type ::= `memref` `&lt;*x` type (`,` memory-space)? `&gt;`
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type with an unknown rank (e.g. <code>memref&lt;*xf32></code>). The purpose of
unranked memrefs is to allow external library functions to receive memref
arguments of any rank without versioning the functions based on the rank.
Other uses of this type are disallowed or will have undefined behavior.</p><p>See
<a href=#builtin_memref-memreftype>MemRefType</a> for more information on
memref types.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// An unranked memref with a memory space of 10.
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span><span class=k>f32</span><span class=p>,</span> <span class=m>10</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-7>Parameters:&nbsp;<a class=headline-hash href=#parameters-7>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>Type</code></td><td></td></tr><tr><td align=center>memorySpace</td><td align=center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=unrankedtensortype>UnrankedTensorType&nbsp;<a class=headline-hash href=#unrankedtensortype>¶</a></h3><p>Multi-dimensional array with unknown dimensions</p><p>Syntax:</p><pre><code>tensor-type ::= `tensor` `&lt;` `*` `x` type `&gt;`
</code></pre><p>An unranked tensor is a type of tensor in which the set of dimensions have
unknown rank. See
<a href=#builtin_rankedtensor-rankedtensortype>RankedTensorType</a>
for more information on tensor types.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-8>Parameters:&nbsp;<a class=headline-hash href=#parameters-8>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>Type</code></td><td></td></tr></tbody></table><h3 id=vectortype>VectorType&nbsp;<a class=headline-hash href=#vectortype>¶</a></h3><p>Multi-dimensional SIMD vector type</p><p>Syntax:</p><pre><code>vector-type ::= `vector` `&lt;` vector-dim-list vector-element-type `&gt;`
vector-element-type ::= float-type | integer-type | index-type
vector-dim-list := (static-dim-list `x`)? (`[` static-dim-list `]` `x`)?
static-dim-list ::= decimal-literal (`x` decimal-literal)*
</code></pre><p>The vector type represents a SIMD style vector used by target-specific
operation sets like AVX or SVE. While the most common use is for 1D
vectors (e.g. vector&lt;16 x f32>) we also support multidimensional registers
on targets that support them (like TPUs). The dimensions of a vector type
can be fixed-length, scalable, or a combination of the two. The scalable
dimensions in a vector are indicated between square brackets ([ ]), and
all fixed-length dimensions, if present, must precede the set of scalable
dimensions. That is, a <code>vector&lt;2x[4]xf32></code> is valid, but <code>vector&lt;[4]x2xf32></code>
is not.</p><p>Vector shapes must be positive decimal integers. 0D vectors are allowed by
omitting the dimension: <code>vector&lt;f32></code>.</p><p>Note: hexadecimal integer literals are not allowed in vector type
declarations, <code>vector&lt;0x42xi32></code> is invalid because it is interpreted as a
2D vector with shape <code>(0, 42)</code> and zero shapes are not allowed.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A 2D fixed-length vector of 3x42 i32 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x42x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// A 1D scalable-length vector that contains a multiple of 4 f32 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=p>[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>

<span class=c>// A 2D scalable-length vector that contains a multiple of 2x8 i8 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=p>[</span><span class=m>2x</span><span class=m>8</span><span class=p>]</span>xf32<span class=p>&gt;</span>

<span class=c>// A 2D mixed fixed/scalable vector that contains 4 scalable vectors of 4 f32 elements.
</span><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=p>[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-9>Parameters:&nbsp;<a class=headline-hash href=#parameters-9>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>shape</td><td align=center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td align=center>elementType</td><td align=center><code>Type</code></td><td></td></tr><tr><td align=center>numScalableDims</td><td align=center><code>unsigned</code></td><td></td></tr></tbody></table><h1 id=handshake-dialect>&lsquo;handshake&rsquo; Dialect</h1><p>Types and operations for the handshake dialect
This dialect defined the <code>handshake</code> dialect, modeling dataflow circuits.
Handshake/dataflow IR is describes independent, unsynchronized processes
communicating data through First-in First-out (FIFO) communication channels.</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#bfloat16-floating-point-type>bfloat16 floating-point type</a></li><li><a href=#complex-number-with-a-parameterized-element-type>Complex number with a parameterized element type</a></li><li><a href=#128-bit-floating-point-type>128-bit floating-point type</a></li><li><a href=#16-bit-floating-point-type>16-bit floating-point type</a></li><li><a href=#32-bit-floating-point-type>32-bit floating-point type</a></li><li><a href=#64-bit-floating-point-type>64-bit floating-point type</a></li><li><a href=#80-bit-floating-point-type>80-bit floating-point type</a></li><li><a href=#map-from-a-list-of-inputs-to-a-list-of-results>Map from a list of inputs to a list of results</a></li><li><a href=#integer-like-type-with-unknown-platform-dependent-bit-width>Integer-like type with unknown platform-dependent bit width</a></li><li><a href=#integer-type-with-arbitrary-precision-up-to-a-fixed-limit>Integer type with arbitrary precision up to a fixed limit</a></li><li><a href=#shaped-reference-to-a-region-of-memory>Shaped reference to a region of memory</a></li><li><a href=#a-unit-type>A unit type</a></li><li><a href=#type-of-a-non-registered-dialect>Type of a non-registered dialect</a></li><li><a href=#multi-dimensional-array-with-a-fixed-number-of-dimensions>Multi-dimensional array with a fixed number of dimensions</a></li><li><a href=#fixed-sized-collection-of-other-types>Fixed-sized collection of other types</a></li><li><a href=#shaped-reference-with-unknown-rank-to-a-region-of-memory>Shaped reference, with unknown rank, to a region of memory</a></li><li><a href=#multi-dimensional-array-with-unknown-dimensions>Multi-dimensional array with unknown dimensions</a></li><li><a href=#multi-dimensional-simd-vector-type>Multi-dimensional SIMD vector type</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#bfloat16type>BFloat16Type</a></li><li><a href=#complextype>ComplexType</a></li><li><a href=#float128type>Float128Type</a></li><li><a href=#float16type>Float16Type</a></li><li><a href=#float32type>Float32Type</a></li><li><a href=#float64type>Float64Type</a></li><li><a href=#float80type>Float80Type</a></li><li><a href=#functiontype>FunctionType</a></li><li><a href=#indextype>IndexType</a></li><li><a href=#integertype>IntegerType</a></li><li><a href=#memreftype>MemRefType</a></li><li><a href=#nonetype>NoneType</a></li><li><a href=#opaquetype>OpaqueType</a></li><li><a href=#rankedtensortype>RankedTensorType</a></li><li><a href=#tupletype>TupleType</a></li><li><a href=#unrankedmemreftype>UnrankedMemRefType</a></li><li><a href=#unrankedtensortype>UnrankedTensorType</a></li><li><a href=#vectortype>VectorType</a></li></ul></li></ul><ul><li><a href=#attribute-constraint-definition>Attribute constraint definition</a><ul><li><a href=#bufferop-seq-or-fifo>BufferOp seq or fifo</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#buffertypeenumattr>BufferTypeEnumAttr</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#handshakebr-circthandshakebranchop>handshake.br (::circt::handshake::BranchOp)</a></li><li><a href=#handshakebuffer-circthandshakebufferop>handshake.buffer (::circt::handshake::BufferOp)</a></li><li><a href=#handshakecond_br-circthandshakeconditionalbranchop>handshake.cond_br (::circt::handshake::ConditionalBranchOp)</a></li><li><a href=#handshakeconstant-circthandshakeconstantop>handshake.constant (::circt::handshake::ConstantOp)</a></li><li><a href=#handshakecontrol_merge-circthandshakecontrolmergeop>handshake.control_merge (::circt::handshake::ControlMergeOp)</a></li><li><a href=#handshakeend-circthandshakeendop>handshake.end (::circt::handshake::EndOp)</a></li><li><a href=#handshakeextmemory-circthandshakeexternalmemoryop>handshake.extmemory (::circt::handshake::ExternalMemoryOp)</a></li><li><a href=#handshakefork-circthandshakeforkop>handshake.fork (::circt::handshake::ForkOp)</a></li><li><a href=#handshakefunc-circthandshakefuncop>handshake.func (::circt::handshake::FuncOp)</a></li><li><a href=#handshakeinstance-circthandshakeinstanceop>handshake.instance (::circt::handshake::InstanceOp)</a></li><li><a href=#handshakejoin-circthandshakejoinop>handshake.join (::circt::handshake::JoinOp)</a></li><li><a href=#handshakelazy_fork-circthandshakelazyforkop>handshake.lazy_fork (::circt::handshake::LazyForkOp)</a></li><li><a href=#handshakeload-circthandshakeloadop>handshake.load (::circt::handshake::LoadOp)</a></li><li><a href=#handshakememory-circthandshakememoryop>handshake.memory (::circt::handshake::MemoryOp)</a></li><li><a href=#handshakemerge-circthandshakemergeop>handshake.merge (::circt::handshake::MergeOp)</a></li><li><a href=#handshakemux-circthandshakemuxop>handshake.mux (::circt::handshake::MuxOp)</a></li><li><a href=#handshakenever-circthandshakeneverop>handshake.never (::circt::handshake::NeverOp)</a></li><li><a href=#handshakepack-circthandshakepackop>handshake.pack (::circt::handshake::PackOp)</a></li><li><a href=#handshakereturn-circthandshakereturnop>handshake.return (::circt::handshake::ReturnOp)</a></li><li><a href=#handshakeselect-circthandshakeselectop>handshake.select (::circt::handshake::SelectOp)</a></li><li><a href=#handshakesink-circthandshakesinkop>handshake.sink (::circt::handshake::SinkOp)</a></li><li><a href=#handshakesource-circthandshakesourceop>handshake.source (::circt::handshake::SourceOp)</a></li><li><a href=#handshakestart-circthandshakestartop>handshake.start (::circt::handshake::StartOp)</a></li><li><a href=#handshakestore-circthandshakestoreop>handshake.store (::circt::handshake::StoreOp)</a></li><li><a href=#handshaketerminator-circthandshaketerminatorop>handshake.terminator (::circt::handshake::TerminatorOp)</a></li><li><a href=#handshakeunpack-circthandshakeunpackop>handshake.unpack (::circt::handshake::UnpackOp)</a></li></ul></li></ul></nav><h2 id=attribute-constraint-definition>Attribute constraint definition&nbsp;<a class=headline-hash href=#attribute-constraint-definition>¶</a></h2><h3 id=bufferop-seq-or-fifo>BufferOp seq or fifo&nbsp;<a class=headline-hash href=#bufferop-seq-or-fifo>¶</a></h3><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=buffertypeenumattr>BufferTypeEnumAttr&nbsp;<a class=headline-hash href=#buffertypeenumattr>¶</a></h3><p>BufferOp seq or fifo</p><p>Syntax:</p><pre><code>!handshake.buffer_type_enum&lt;
  ::BufferTypeEnum   # value
&gt;
</code></pre><h4 id=parameters-10>Parameters:&nbsp;<a class=headline-hash href=#parameters-10>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>value</td><td align=center><code>::BufferTypeEnum</code></td><td>an enum of type BufferTypeEnum</td></tr></tbody></table><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=handshakebr-circthandshakebranchop><code>handshake.br</code> (::circt::handshake::BranchOp)&nbsp;<a class=headline-hash href=#handshakebr-circthandshakebranchop>¶</a></h3><p>branch operation</p><p>The branch operation represents an unconditional
branch. The single data input is propagated to the single
successor. The input must be triggered by some predecessor to
avoid continous triggering of a successor block.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> br <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataOperand</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataResult</code></td><td>any type</td></tr></tbody></table><h3 id=handshakebuffer-circthandshakebufferop><code>handshake.buffer</code> (::circt::handshake::BufferOp)&nbsp;<a class=headline-hash href=#handshakebuffer-circthandshakebufferop>¶</a></h3><p>buffer operation</p><p>The buffer operation represents a buffer operation. $slots
must be an unsigned integer larger than 0. $bufferType=BufferTypeEnum::seq indicates a
nontransparent buffer, while $bufferType=BufferTypeEnum::fifo indicates a transparent
buffer.</p><p>An &lsquo;initValues&rsquo; attribute containing a list of integer values may be provided.
The list must be of the same length as the number of slots. This will
initialize the buffer with the given values upon reset.
For now, only sequential buffers are allowed to have initial values.
@todo: How to support different init types? these have to be stored (and
retrieved) as attributes, hence they must be of a known type.</p><p>Traits: HasClock, HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td align=center><code>bufferType</code></td><td align=center>::circt::handshake::BufferTypeEnumAttr</td><td>BufferOp seq or fifo</td></tr><tr><td align=center><code>initValues</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakecond_br-circthandshakeconditionalbranchop><code>handshake.cond_br</code> (::circt::handshake::ConditionalBranchOp)&nbsp;<a class=headline-hash href=#handshakecond_br-circthandshakeconditionalbranchop>¶</a></h3><p>conditional branch operation</p><p>The cbranch operation represents a conditional
branch. The data input is propagated to one of the two outputs
based on the condition input.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>=</span> conditional_branch <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%data</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>conditionOperand</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>dataOperand</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueResult</code></td><td>any type</td></tr><tr><td align=center><code>falseResult</code></td><td>any type</td></tr></tbody></table><h3 id=handshakeconstant-circthandshakeconstantop><code>handshake.constant</code> (::circt::handshake::ConstantOp)&nbsp;<a class=headline-hash href=#handshakeconstant-circthandshakeconstantop>¶</a></h3><p>constant operation</p><p>Syntax:</p><pre><code>operation ::= `handshake.constant` $ctrl attr-dict `:` qualified(type($result))
</code></pre><p>The const has a constant value. When triggered by its
single <code>ctrl</code> input, it sends the constant value to its single
successor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=nv>%ctrl</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ctrl</code></td><td>none type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakecontrol_merge-circthandshakecontrolmergeop><code>handshake.control_merge</code> (::circt::handshake::ControlMergeOp)&nbsp;<a class=headline-hash href=#handshakecontrol_merge-circthandshakecontrolmergeop>¶</a></h3><p>control merge operation</p><p>The control_merge operation represents a
(nondeterministic) control merge. Any input is propagated to the
first output and the index of the propagated input is sent to the
second output. The number of inputs corresponds to the number of
predecessor blocks. ControlMerge is a control-only
component(i.e., has no data but only bidirectional handshake).</p><p>Example:</p><pre><code>%0, %idx = control_merge %a, %b, %c : i32
</code></pre><p>Traits: HasClock, HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, MergeLikeOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataOperands</code></td><td>any type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr><tr><td align=center><code>index</code></td><td>index</td></tr></tbody></table><h3 id=handshakeend-circthandshakeendop><code>handshake.end</code> (::circt::handshake::EndOp)&nbsp;<a class=headline-hash href=#handshakeend-circthandshakeendop>¶</a></h3><p>end operation</p><p>Syntax:</p><pre><code>operation ::= `handshake.end` operands attr-dict `:` qualified(type($control)) `,` qualified(type($operands))
</code></pre><p>The end propagates the result of the appropriate
return operation from one of its inputs to its single output after
all memory accesses have completed. Currently not used(data
returned through ReturnOp).</p><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, NamedIOInterface</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>control</code></td><td>any type</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=handshakeextmemory-circthandshakeexternalmemoryop><code>handshake.extmemory</code> (::circt::handshake::ExternalMemoryOp)&nbsp;<a class=headline-hash href=#handshakeextmemory-circthandshakeexternalmemoryop>¶</a></h3><p>external memory</p><p>Syntax:</p><pre><code>operation ::= `handshake.extmemory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $memref `:` qualified(type($memref)) `)` `(` $inputs `)` attr-dict `:` functional-type($inputs, $outputs)
</code></pre><p>An ExternalMemoryOp represents a wrapper around a memref input to a
handshake function. The semantics of the load/store operands are identical
to what is decribed for MemoryOp. The only difference is that the first
operand to this operand is a <code>memref</code> value.
Upon lowering to FIRRTL, a handshake interface will be created in the
top-level component for each load- and store which connected to this memory.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>handshake<span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>(</span><span class=nv>%i</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%v</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%mem</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%ctrl</span><span class=p>:</span> none<span class=p>)</span> <span class=p>-&gt;</span> none <span class=p>{</span>
  <span class=nv>%stCtrl</span> <span class=p>=</span> extmemory<span class=p>[</span><span class=nl>ld =</span> <span class=m>0</span><span class=p>,</span> <span class=nl>st =</span> <span class=m>1</span><span class=p>]</span><span class=p>(</span><span class=nv>%mem</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>(</span><span class=nv>%vout</span><span class=p>,</span> <span class=nv>%addr</span><span class=p>)</span> <span class=p>{</span><span class=nl>id =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>none<span class=p>)</span>
  <span class=nv>%vout</span><span class=p>,</span> <span class=nv>%addr</span> <span class=p>=</span> store<span class=p>(</span><span class=nv>%v</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%ctrl</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> none<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, NamedIOInterface</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ldCount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>stCount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>id</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>outputs</code></td><td>any type</td></tr></tbody></table><h3 id=handshakefork-circthandshakeforkop><code>handshake.fork</code> (::circt::handshake::ForkOp)&nbsp;<a class=headline-hash href=#handshakefork-circthandshakeforkop>¶</a></h3><p>fork operation</p><p>The fork operation represents a fork operation. A
single input is replicated to N outputs and distributed to each
output as soon as the corresponding successor is available.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span><span class=p>:</span><span class=nl>2 =</span> fork <span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasClock, HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakefunc-circthandshakefuncop><code>handshake.func</code> (::circt::handshake::FuncOp)&nbsp;<a class=headline-hash href=#handshakefunc-circthandshakefuncop>¶</a></h3><p>Handshake dialect function.</p><p>The func operation represents a handshaked function.
This is almost exactly like a standard FuncOp, except that it has
some extra verification conditions. In particular, each Value must
only have a single use.</p><p>Traits: HasClock, IsolatedFromAbove</p><p>Interfaces: FunctionOpInterface, OpAsmOpInterface, RegionKindInterface, Symbol</p><h3 id=handshakeinstance-circthandshakeinstanceop><code>handshake.instance</code> (::circt::handshake::InstanceOp)&nbsp;<a class=headline-hash href=#handshakeinstance-circthandshakeinstanceop>¶</a></h3><p>module instantiate operation</p><p>Syntax:</p><pre><code>operation ::= `handshake.instance` $module `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>instance</code> operation represents the instantiation of a module. This
is similar to a function call, except that different instances of the
same module are guaranteed to have their own distinct state.
The instantiated module is encoded as a symbol reference attribute named
&ldquo;module&rdquo;. An instance operation takes a control input as its last argument
and returns a control output as its last result.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%2</span><span class=p>:</span><span class=nl>2 =</span> handshake<span class=p>.</span>instance <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%ctrl</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> none<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> none<span class=p>)</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: CallOpInterface, ControlInterface, NamedIOInterface</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>module</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=handshakejoin-circthandshakejoinop><code>handshake.join</code> (::circt::handshake::JoinOp)&nbsp;<a class=headline-hash href=#handshakejoin-circthandshakejoinop>¶</a></h3><p>join operation</p><p>A control-only synchronizer. Produces a valid output when all
inputs become available.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> join <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>data</code></td><td>none type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>none type</td></tr></tbody></table><h3 id=handshakelazy_fork-circthandshakelazyforkop><code>handshake.lazy_fork</code> (::circt::handshake::LazyForkOp)&nbsp;<a class=headline-hash href=#handshakelazy_fork-circthandshakelazyforkop>¶</a></h3><p>lazy fork operation</p><p>The lazy_fork operation represents a lazy fork operation.
A single input is replicated to N outputs and distributed to each
output when all successors are available.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span><span class=p>:</span><span class=nl>2 =</span> lazy_fork <span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakeload-circthandshakeloadop><code>handshake.load</code> (::circt::handshake::LoadOp)&nbsp;<a class=headline-hash href=#handshakeload-circthandshakeloadop>¶</a></h3><p>load operation</p><p>Load memory port, sends load requests to MemoryOp. From dataflow
predecessor, receives address indices and a control-only value
which signals completion of all previous memory accesses which
target the same memory. When all inputs are received, the load
sends the address indices to MemoryOp. When the MemoryOp returns
a piece of data, the load sends it to its dataflow successor.</p><p>Operands: address indices (from predecessor), data (from MemoryOp), control-only input.
Results: data (to successor), address indices (to MemoryOp).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%dataToSucc</span><span class=p>,</span> <span class=nv>%addr1ToMem</span><span class=p>,</span> <span class=nv>%addr2ToMem</span> <span class=p>=</span> load <span class=p>[</span><span class=nv>%addr1</span><span class=p>,</span> <span class=nv>%addr2</span><span class=p>]</span> <span class=nv>%dataFromMem</span><span class=p>,</span> <span class=nv>%ctrl</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i16</span><span class=p>,</span> <span class=k>index</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, NamedIOInterface</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>addresses</code></td><td>any type</td></tr><tr><td align=center><code>data</code></td><td>any type</td></tr><tr><td align=center><code>ctrl</code></td><td>none type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataResult</code></td><td>any type</td></tr><tr><td align=center><code>addressResults</code></td><td>any type</td></tr></tbody></table><h3 id=handshakememory-circthandshakememoryop><code>handshake.memory</code> (::circt::handshake::MemoryOp)&nbsp;<a class=headline-hash href=#handshakememory-circthandshakememoryop>¶</a></h3><p>memory</p><p>Syntax:</p><pre><code>operation ::= `handshake.memory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $inputs `)` attr-dict `:` $memRefType `,` functional-type($inputs, $outputs)
</code></pre><p>Each MemoryOp represents an independent memory or memory region (BRAM or external memory).
It receives memory access requests from load and store operations. For every request,
it returns data (for load) and a data-less token indicating completion.
The memory op represents a flat, unidimensional memory.
Operands: all stores (stdata1, staddr1, stdata2, staddr2, &mldr;), then all loads (ldaddr1, ldaddr2,&mldr;)
Outputs: all load outputs, ordered the same as
load addresses (lddata1, lddata2, &mldr;), followed by all none outputs,
ordered as operands (stnone1, stnone2,&mldr;ldnone1, ldnone2,&mldr;)</p><p>Traits: HasClock, HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, MemoryOpInterface, NamedIOInterface</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ldCount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>stCount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>id</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>memRefType</code></td><td align=center>::mlir::TypeAttr</td><td>memref type attribute</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>outputs</code></td><td>any type</td></tr></tbody></table><h3 id=handshakemerge-circthandshakemergeop><code>handshake.merge</code> (::circt::handshake::MergeOp)&nbsp;<a class=headline-hash href=#handshakemerge-circthandshakemergeop>¶</a></h3><p>merge operation</p><p>The merge operation represents a (nondeterministic)
merge operation. Any input is propagated to the single output. The
number of inputs corresponds to the number of predecessor
blocks.</p><p>Example:</p><pre><code>%0 = merge %a, %b, %c : i32
</code></pre><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, MergeLikeOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr></tbody></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataOperands</code></td><td>any type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakemux-circthandshakemuxop><code>handshake.mux</code> (::circt::handshake::MuxOp)&nbsp;<a class=headline-hash href=#handshakemux-circthandshakemuxop>¶</a></h3><p>mux operation</p><p>The mux operation represents a(deterministic) merge operation.
Operands: select, data0, data1, data2, &mldr;</p><p>The &lsquo;select&rsquo; operand is received from ControlMerge of the same
block and it represents the index of the data operand that the mux
should propagate to its single output. The number of data inputs
corresponds to the number of predecessor blocks.</p><p>The mux operation is intended solely for control+dataflow selection.
For purely dataflow selection, use the &lsquo;select&rsquo; operation instead.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> mux <span class=nv>%select</span> <span class=p>[</span><span class=nv>%data0</span><span class=p>,</span> <span class=nv>%data1</span><span class=p>,</span> <span class=nv>%data2</span><span class=p>]</span> <span class=p>{</span>attributes<span class=p>}</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, MergeLikeOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataType</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>selectOperand</code></td><td>any type</td></tr><tr><td align=center><code>dataOperands</code></td><td>any type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakenever-circthandshakeneverop><code>handshake.never</code> (::circt::handshake::NeverOp)&nbsp;<a class=headline-hash href=#handshakenever-circthandshakeneverop>¶</a></h3><p>never operation</p><p>Syntax:</p><pre><code>operation ::= `handshake.never` attr-dict `:` qualified(type($result))
</code></pre><p>The never operation represents disconnected data
source. The source never sets any &lsquo;valid&rsquo; signal which will
never trigger the successor at any point in time.</p><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakepack-circthandshakepackop><code>handshake.pack</code> (::circt::handshake::PackOp)&nbsp;<a class=headline-hash href=#handshakepack-circthandshakepackop>¶</a></h3><p>packs a tuple</p><p>The <code>pack</code> operation constructs a tuple from separate values.
The number of operands corresponds to the number of tuple elements.
Similar to <code>join</code>, the output is ready when all inputs are ready.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%tuple</span> <span class=p>=</span> handshake<span class=p>.</span>pack <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>{</span>attributes<span class=p>}</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>Fixed-sized collection of other types</td></tr></tbody></table><h3 id=handshakereturn-circthandshakereturnop><code>handshake.return</code> (::circt::handshake::ReturnOp)&nbsp;<a class=headline-hash href=#handshakereturn-circthandshakereturnop>¶</a></h3><p>Handshake dialect return.</p><p>Syntax:</p><pre><code>operation ::= `handshake.return` operands attr-dict `:` qualified(type(operands))
</code></pre><p>The return operation represents a handshaked
function. This is almost exactly like a standard ReturnOp, except
that it exists in a handshake.func. It has the same operands as
standard ReturnOp which it replaces and an additional control -
only operand(exit point of control - only network).</p><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a>, Terminator</p><p>Interfaces: ControlInterface, NamedIOInterface</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr><tr><td align=center><code>control</code></td><td>none type</td></tr></tbody></table><h3 id=handshakeselect-circthandshakeselectop><code>handshake.select</code> (::circt::handshake::SelectOp)&nbsp;<a class=headline-hash href=#handshakeselect-circthandshakeselectop>¶</a></h3><p>Select operation</p><p>The select operation will select between two inputs based on an input
conditional. The select operation differs from a mux in that</p><ol><li>All operands must be valid before the operation can transact</li><li>All operands will be transacted at simultaneously</li></ol><p>The &lsquo;select&rsquo; operation is intended to handle &lsquo;std.select&rsquo; and other
ternary-like operators, which considers strictly dataflow. The &lsquo;mux&rsquo; operator
considers control+dataflow between blocks.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%res</span> <span class=p>=</span> select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condOperand</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>trueOperand</code></td><td>any type</td></tr><tr><td align=center><code>falseOperand</code></td><td>any type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakesink-circthandshakesinkop><code>handshake.sink</code> (::circt::handshake::SinkOp)&nbsp;<a class=headline-hash href=#handshakesink-circthandshakesinkop>¶</a></h3><p>sink operation</p><p>The sink operation discards any data that arrives at its
input.The sink has no successors and it can continuously consume data.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sink <span class=nv>%data</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, NamedIOInterface</p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>any type</td></tr></tbody></table><h3 id=handshakesource-circthandshakesourceop><code>handshake.source</code> (::circt::handshake::SourceOp)&nbsp;<a class=headline-hash href=#handshakesource-circthandshakesourceop>¶</a></h3><p>source operation</p><p>The source operation represents continuous token
source. The source continously sets a &lsquo;valid&rsquo; signal which the
successor can consume at any point in time.</p><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakestart-circthandshakestartop><code>handshake.start</code> (::circt::handshake::StartOp)&nbsp;<a class=headline-hash href=#handshakestart-circthandshakestartop>¶</a></h3><p>start operation</p><p>Syntax:</p><pre><code>operation ::= `handshake.start` attr-dict `:` qualified(type($result))
</code></pre><p>Triggers execution of the control - only network. Placed in entry
block. Currently not used( trigger given as function argument)</p><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, NamedIOInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>control</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>none type</td></tr></tbody></table><h3 id=handshakestore-circthandshakestoreop><code>handshake.store</code> (::circt::handshake::StoreOp)&nbsp;<a class=headline-hash href=#handshakestore-circthandshakestoreop>¶</a></h3><p>store operation</p><p>Store memory port, sends store requests to MemoryOp. From dataflow
predecessors, receives address indices, data, and a control-only
value which signals completion of all previous memory accesses
which target the same memory. When all inputs are received, the
store sends the address and data to MemoryOp.</p><p>Operands: address indices, data, control-only input.
Results: data and address indices (sent to MemoryOp).
Types: data type followed by address type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%dataToMem</span><span class=p>,</span> <span class=nv>%addrToMem</span> <span class=p>=</span> store <span class=p>[</span><span class=nv>%addr1</span><span class=p>,</span> <span class=nv>%addr2</span><span class=p>]</span> <span class=nv>%dataFromPred</span> <span class=p>,</span> <span class=nv>%ctrl</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i16</span><span class=p>,</span> <span class=k>index</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>addresses</code></td><td>any type</td></tr><tr><td align=center><code>data</code></td><td>any type</td></tr><tr><td align=center><code>ctrl</code></td><td>none type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dataResult</code></td><td>any type</td></tr><tr><td align=center><code>addressResult</code></td><td>any type</td></tr></tbody></table><h3 id=handshaketerminator-circthandshaketerminatorop><code>handshake.terminator</code> (::circt::handshake::TerminatorOp)&nbsp;<a class=headline-hash href=#handshaketerminator-circthandshaketerminatorop>¶</a></h3><p>handshake terminator operation</p><p>This op is used as a terminator in every block of the dataflow
netlist (as a replacement for StandardOp branches). It has no
functionality and can be removed in some subsequent pass, when the
block structure is removed.</p><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a>, Terminator</p><p>Interfaces: ControlInterface, NamedIOInterface</p><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dests</code></td><td>any successor</td></tr></tbody></table><h3 id=handshakeunpack-circthandshakeunpackop><code>handshake.unpack</code> (::circt::handshake::UnpackOp)&nbsp;<a class=headline-hash href=#handshakeunpack-circthandshakeunpackop>¶</a></h3><p>unpacks a tuple</p><p>The <code>unpack</code> operation assigns each value of a tuple to a separate
value for further processing. The number of results corresponds
to the number of tuple elements.
Similar to <code>fork</code>, each output is distributed as soon as the corresponding
successor is ready.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>=</span> handshake<span class=p>.</span>unpack <span class=nv>%tuple</span> <span class=p>{</span>attributes<span class=p>}</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: HasParent<a href=handshake::FuncOp>handshake::FuncOp</a></p><p>Interfaces: ControlInterface, ExecutableOpInterface, GeneralOpInterface, NamedIOInterface</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>Fixed-sized collection of other types</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/FIRRTLAttributes/><i class="fas fa-arrow-left" aria-hidden=true></i>Prev -</a>
<a class="nav nav-next" href=/docs/Dialects/Calyx/ title="'calyx' Dialect">Next - 'calyx' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FIRRTLAttributes/></a></li><li class=active><a href=/docs/Dialects/Handshake/>'builtin' Dialect</a></li><li><a href=/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li><a href=/docs/Dialects/Comb/>'comb' Dialect</a></li><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/FSM/>'fsm' Dialect</a></li><li><a href=/docs/Dialects/HW/>'hw' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'hw' Dialect</a></li><li><a href=/docs/Dialects/MSFT/>'hw' Dialect</a></li><li><a href=/docs/Dialects/SV/>'hw' Dialect</a></li><li><a href=/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=/docs/Dialects/Seq/>'seq' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li><li><a href=/docs/ESI/types/>ESI data types and communication types</a></li><li><a href=/docs/ESI/services/>ESI Global Services</a></li><li><a href=/docs/ESI/software_api/>ESI Software APIs</a></li><li><a href=/docs/ESI/notes/>Miscellaneous Notes</a></li></ul></li><li><a href=/docs/CalyxPasses/></a></li><li><a href=/docs/FSMPasses/></a></li><li><a href=/docs/HWPasses/></a></li><li><a href=/docs/RationaleComb/>`comb` Dialect Rationale</a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/RationaleFSM/>FSM Dialect Rationale</a></li><li><a href=/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=/docs/RationaleHandshake/>Handshake Dialect Rationale</a></li><li><a href=/docs/RationaleHW/>HW Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PyCDE/>PyCDE</a></li><li><a href=/docs/RationaleSeq/>Seq(uential) Dialect Rationale</a></li><li><a href=/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=/docs/RationaleSV/>SV Dialect Rationale</a></li><li><a href=/docs/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li><li><a href=/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>